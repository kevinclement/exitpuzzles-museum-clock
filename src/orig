

#include "EEPROM.h"
#include "BluetoothSerial.h"
#include <math.h>

bool ENABLED              = true;      // whether motors are enabled
int  HOUR_ADDR            = 0;         // where to store hour in eeprom
int  STORED_HOUR          = 0;
int  HOUR                 = 0;
int  HOUR_STEPPER         = 0;
int  HOUR_STEPPER_ADDR    = 20;
int  HOUR_STEPPER_STORED  = 0;
int  MINUTE_ADDR          = 4;         // where to store minute in eeprom
int  MINUTE               = 0;
int  STORED_MINUTE        = 0;
int  MINUTE_STEPPER       = 0;
int  MINUTE_STEPPER_ADDR  = 24;
int  MINUTE_STEPPER_STORED= 0;
int  TARGET_HOUR          = 0;
int  TARGET_HOUR_ADDR     = 8;
int  TARGET_MINUTE        = 0;
int  TARGET_MINUTE_ADDR   = 12;
int  TARGET_DEBOUNCE_ADDR = 16;
int  TARGET_DEBOUNCE      = 0;
bool LOCKED               = true;
bool LOCKED_OVERRIDE      = false;
char CRLF[]               = "\r\n";


void setup(){

  readStoredVars();
  printHelp();
  printVariables();

}

void readStoredVars() {
  EEPROM.begin(64);
  EEPROM.get(HOUR_ADDR, STORED_HOUR);
  HOUR = STORED_HOUR;
  EEPROM.get(MINUTE_ADDR, STORED_MINUTE);
  MINUTE = STORED_MINUTE;
  EEPROM.get(TARGET_HOUR_ADDR, TARGET_HOUR);
  EEPROM.get(TARGET_MINUTE_ADDR, TARGET_MINUTE);
  EEPROM.get(TARGET_DEBOUNCE_ADDR, TARGET_DEBOUNCE);
  EEPROM.get(HOUR_STEPPER_ADDR, HOUR_STEPPER_STORED);
  EEPROM.get(MINUTE_STEPPER_ADDR, MINUTE_STEPPER_STORED);
}

void printVariables() { 
  p(CRLF);
  p("Current Variables:%s", CRLF);
  p("  hour:        %d%s", STORED_HOUR, CRLF);
  p("  hour step:   %d%s", HOUR_STEPPER_STORED, CRLF);
  p("  minute:      %d%s", STORED_MINUTE, CRLF);
  p("  minute step: %d%s", MINUTE_STEPPER_STORED, CRLF);
  p("  target:      %d:%d%s", TARGET_HOUR, TARGET_MINUTE, CRLF);
  p("  debounce:    %d%s", TARGET_DEBOUNCE, CRLF);
}

void printStatus() {
  p("%d:%d => ", HOUR, MINUTE);
  p("h_stepper: %d h_stepper_stored: %d h_stored: %d ", HOUR_STEPPER, HOUR_STEPPER_STORED, STORED_HOUR);
  p("m_stepper: %d m_stepper_stored: %d m_stored: %d ", MINUTE_STEPPER, MINUTE_STEPPER_STORED, STORED_MINUTE);
  p("locked: %s%s", LOCKED ? "true" : "false", CRLF);
}

int timeToPos(int t, double denom) {
  return -(t * (STEPS / denom));
}

bool solved() {
  static long timeSolved;
  bool solved = false;

  // allow +/-2 accuracy for minute since its harder
  int slack = 3;
  if (HOUR == TARGET_HOUR && MINUTE >= TARGET_MINUTE - slack && MINUTE <= TARGET_MINUTE + slack) {
    // check to make sure they settled on the number for a little bit
    if (timeSolved == 0) {
      timeSolved = millis();
    } else if (millis() - timeSolved > TARGET_DEBOUNCE) {
      if (LOCKED) {
        p("Clock Solved!!%s", CRLF);
      }
      solved = true;
    }
  } else {
    timeSolved = 0;
  }
  
  return solved;
}

void resetState() {
  p("  setting time to 00:00%s", CRLF);
  ENABLED = false;
  zeroing = 0;
  HOUR = 0;
  STORED_HOUR = 0;
  HOUR_STEPPER = 0;
  HOUR_STEPPER_STORED = 0;
  MINUTE = 0;
  STORED_MINUTE = 0;
  MINUTE_STEPPER = 0;
  MINUTE_STEPPER_STORED = 0;
  LOCKED = true;
  hour.setCount(0);
  minute.setCount(0);
  EEPROM.put(HOUR_ADDR, 0);
  EEPROM.put(HOUR_STEPPER_ADDR, 0);
  EEPROM.put(MINUTE_ADDR, 0);
  EEPROM.put(MINUTE_STEPPER_ADDR, 0);
  EEPROM.commit();
}

void loop(){

  // check if puzzle is solved
  if (solved() || LOCKED_OVERRIDE) {
    LOCKED = false;
  } else { 
    LOCKED = true;
  }

  // check if we are zeroing out steppers
  if (zeroing > 0 && (millis() - zeroing > 50) && stepperHour.distanceToGo() == 0 && stepperMinute.distanceToGo() == 0) {
    p("  DONE. Resetting all variables.%s", CRLF);
    resetState();
    zeroing_done = millis();
  }
  if (zeroing_done > 0 && millis() - zeroing_done > 3000) {
    p("  DONE RESETTING.  Enabling back.%s", CRLF);
    zeroing_done = 0;
    ENABLED = true;
  }



}
