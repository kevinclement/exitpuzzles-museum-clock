

#include "EEPROM.h"
#include "BluetoothSerial.h"
#include <math.h>

bool ENABLED              = true;      // whether motors are enabled
int  HOUR_ADDR            = 0;         // where to store hour in eeprom
int  STORED_HOUR          = 0;
int  HOUR                 = 0;
int  HOUR_STEPPER         = 0;
int  HOUR_STEPPER_ADDR    = 20;
int  HOUR_STEPPER_STORED  = 0;
int  MINUTE_ADDR          = 4;         // where to store minute in eeprom
int  MINUTE               = 0;
int  STORED_MINUTE        = 0;
int  MINUTE_STEPPER       = 0;
int  MINUTE_STEPPER_ADDR  = 24;
int  MINUTE_STEPPER_STORED= 0;
int  TARGET_HOUR          = 0;
int  TARGET_HOUR_ADDR     = 8;
int  TARGET_MINUTE        = 0;
int  TARGET_MINUTE_ADDR   = 12;
int  TARGET_DEBOUNCE_ADDR = 16;
int  TARGET_DEBOUNCE      = 0;
bool LOCKED               = true;
bool LOCKED_OVERRIDE      = false;
char CRLF[]               = "\r\n";


void setup(){

  readStoredVars();
  printHelp();
  printVariables();

}

void readStoredVars() {
  EEPROM.begin(64);
  EEPROM.get(HOUR_ADDR, STORED_HOUR);
  HOUR = STORED_HOUR;
  EEPROM.get(MINUTE_ADDR, STORED_MINUTE);
  MINUTE = STORED_MINUTE;
  EEPROM.get(TARGET_HOUR_ADDR, TARGET_HOUR);
  EEPROM.get(TARGET_MINUTE_ADDR, TARGET_MINUTE);
  EEPROM.get(TARGET_DEBOUNCE_ADDR, TARGET_DEBOUNCE);
  EEPROM.get(HOUR_STEPPER_ADDR, HOUR_STEPPER_STORED);
  EEPROM.get(MINUTE_STEPPER_ADDR, MINUTE_STEPPER_STORED);
}

void printVariables() { 
  p(CRLF);
  p("Current Variables:%s", CRLF);
  p("  hour:        %d%s", STORED_HOUR, CRLF);
  p("  hour step:   %d%s", HOUR_STEPPER_STORED, CRLF);
  p("  minute:      %d%s", STORED_MINUTE, CRLF);
  p("  minute step: %d%s", MINUTE_STEPPER_STORED, CRLF);
  p("  target:      %d:%d%s", TARGET_HOUR, TARGET_MINUTE, CRLF);
  p("  debounce:    %d%s", TARGET_DEBOUNCE, CRLF);
}

void printStatus() {
  p("%d:%d => ", HOUR, MINUTE);
  p("h_stepper: %d h_stepper_stored: %d h_stored: %d ", HOUR_STEPPER, HOUR_STEPPER_STORED, STORED_HOUR);
  p("m_stepper: %d m_stepper_stored: %d m_stored: %d ", MINUTE_STEPPER, MINUTE_STEPPER_STORED, STORED_MINUTE);
  p("locked: %s%s", LOCKED ? "true" : "false", CRLF);
}

void setHour(int hourPos) {
  HOUR_STEPPER = hourPos / RESOLUTION;
  int posHour = -posToTime(hourPos, 12);

  HOUR = posHour + STORED_HOUR;
  if (HOUR < 0) {
    HOUR += 12;
  } else if (HOUR >= 12) {
    HOUR -= 12;
  }
 
  printStatus();
    
  EEPROM.put(HOUR_ADDR, HOUR);
  EEPROM.put(HOUR_STEPPER_ADDR, HOUR_STEPPER);
  EEPROM.commit();
}

void setMinute(int minutePos) {
  MINUTE_STEPPER = minutePos / RESOLUTION;
  int posMinute = -posToTime(minutePos, 60);
  
  MINUTE = posMinute + STORED_MINUTE;
  if (MINUTE < 0) {
    MINUTE += 60;
  } else if (MINUTE >= 60) {
    MINUTE -= 60;
  }

  printStatus();
    
  EEPROM.put(MINUTE_ADDR, MINUTE);
  EEPROM.put(MINUTE_STEPPER_ADDR, MINUTE_STEPPER);
  EEPROM.commit();
}

int timeToPos(int t, double denom) {
  return -(t * (STEPS / denom));
}

int posToTime(int p, int denom) {
  if (p > (STEPS * RESOLUTION)) {
    p %= (STEPS * RESOLUTION);
  } 

  return (int)(round(( p / (float)RESOLUTION / STEPS ) * denom)) % denom;  
}

bool solved() {
  static long timeSolved;
  bool solved = false;

  // allow +/-2 accuracy for minute since its harder
  int slack = 3;
  if (HOUR == TARGET_HOUR && MINUTE >= TARGET_MINUTE - slack && MINUTE <= TARGET_MINUTE + slack) {
    // check to make sure they settled on the number for a little bit
    if (timeSolved == 0) {
      timeSolved = millis();
    } else if (millis() - timeSolved > TARGET_DEBOUNCE) {
      if (LOCKED) {
        p("Clock Solved!!%s", CRLF);
      }
      solved = true;
    }
  } else {
    timeSolved = 0;
  }
  
  return solved;
}

void resetState() {
  p("  setting time to 00:00%s", CRLF);
  ENABLED = false;
  zeroing = 0;
  HOUR = 0;
  STORED_HOUR = 0;
  HOUR_STEPPER = 0;
  HOUR_STEPPER_STORED = 0;
  MINUTE = 0;
  STORED_MINUTE = 0;
  MINUTE_STEPPER = 0;
  MINUTE_STEPPER_STORED = 0;
  LOCKED = true;
  hour.setCount(0);
  minute.setCount(0);
  EEPROM.put(HOUR_ADDR, 0);
  EEPROM.put(HOUR_STEPPER_ADDR, 0);
  EEPROM.put(MINUTE_ADDR, 0);
  EEPROM.put(MINUTE_STEPPER_ADDR, 0);
  EEPROM.commit();
}

void loop(){

  // check if puzzle is solved
  if (solved() || LOCKED_OVERRIDE) {
    LOCKED = false;
  } else { 
    LOCKED = true;
  }

  // if motors disabled, turn off
  digitalWrite(ENABLE_PIN, ENABLED ? LOW : HIGH);

  // handle lock/unlock motor
  digitalWrite(LOCK_PIN, LOCKED ? HIGH : LOW);

  // check if we are zeroing out steppers
  if (zeroing > 0 && (millis() - zeroing > 50) && stepperHour.distanceToGo() == 0 && stepperMinute.distanceToGo() == 0) {
    p("  DONE. Resetting all variables.%s", CRLF);
    resetState();
    zeroing_done = millis();
  }
  if (zeroing_done > 0 && millis() - zeroing_done > 3000) {
    p("  DONE RESETTING.  Enabling back.%s", CRLF);
    zeroing_done = 0;
    ENABLED = true;
  }

  // move steppers
  stepperHour.moveTo(HOUR_STEPPER);
  stepperHour.setSpeed(100);
  stepperHour.runSpeedToPosition();

  stepperMinute.moveTo(MINUTE_STEPPER);
  stepperMinute.setSpeed(100);
  stepperMinute.runSpeedToPosition();

  int newHourPos = hour.getCount();
  if (newHourPos != hourPos) {    
    if (millis() - lastHour > ENCODER_DEBOUNCE) {
      setHour(newHourPos);
    }
    lastHour = millis();
    hourPos = newHourPos;
  }

  int newMinutePos =  minute.getCount();
  if (newMinutePos != minutePos) {
    if (millis() - lastMinute > ENCODER_DEBOUNCE) {
      setMinute(newMinutePos);
    }
    lastMinute = millis();
    minutePos = newMinutePos;
  }
}
